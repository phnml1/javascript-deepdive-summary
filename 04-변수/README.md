# 04장 변수

## 변수에 대하여

컴퓨터는 데이터를 메모리에 저장하고, 각 메모리셀에 데이터를 저장하거나 읽어들인다. 하지만, 메모리 주소를 통해 값에 직접 접근하는 것은 위험하므로, 자바스크립트는 직접적으로 메모리 제어를 하는 것을 허용하지 않는다. (값이 저장 될 메모리주소는 코드가 실행될때마다 변경되므로)

그러므로 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재**사용하기 위해 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위한 이름인 `변수`** 라는 메커니즘을 사용한다. 간단히 말하면, **변수는 값의 위치를 가리키는 상징적인 이름**이다.

.

```jsx
let result = 30;
```

- 여기서 `result` 는 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 = `변수이름`
- 변수에 저장된 값(위 예제에서 30) = `변수값`
- 변수에 값을 저장하는 행위 = `할당(Assignment, 대입, 저장)`
- 변수에 저장된 값을 읽어 들이는 것 = `참조(Reference)`

## 변수 선언

## 식별자란?

`**식별자**` 는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말하며, 값이 아닌 **메모리 주소**를 기억하고 있다. (네이밍규칙이 따로 있음)  

var, let, const와 같은 **키워드**를 만나면 변수를 선언할 수 있다. (변수 이름, 함수 이름, 클래스 이름은 모두 식별자)

```
var 키워드는 여러 단점이 있다. var 키워드는 블록 레벨 스코프(Block-Level Scope)를 지원하지 않고, 함수 레벨 스코프(Functional-Level Scope)를 지원했다.
이로 인해 의도치 않게 "전역 변수가 선언"되어 심각한 부작용이 발생할 수 있다.

이런 var 키워드의 단점을 보완하기위해 등장한 것들이 ES6에 도입된 let과 const 다.
이 둘은 블록 레벨 스코프를 지원한다.
```

```js
let score;
```

위 변수 선언문은 변수 이름을 등록하고 값을 저장할 **메모리 공간을 할당**했다. (값은 아직 할당 x) 이렇게 **확보한 메모리공간 에는 암묵적으로 undefined라는 값(자바스크립트에서 제공하는 원시타입의 값)이 할당되어 초기화 된다.**

- 변수 선언한 이후, 변수에 값은 아직 할당하지 않았다.
- 따라서, 확보된 메모리 공간은 비어있을 것으로 생각할 수 있으나 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined` 값이 `암묵적으로 할당`되어 초기화된다. 

```
등록된 변수 이름은 추후 자세히 살펴볼 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역인 ***실행 컨텍스트***라는 
곳에 등록된다.
```

- 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)` 가 발생
- 이는, 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러

즉, 위의 score에 접근한다면, undefined라는 값을 얻을 수 있고, 선언되지 않은 변수에 접근할 시 참조 에러가 발생한다.

## **변수 선언의 실행시점과 변수 호이스팅**

```jsx
console.log(score); //undefined

var score; // 변수 선언문
```

위 예제는 참조 에러가 아닌 undefined를 출력하는데, 그 이유는

 💡 **"변수 선언(선언 단계 & 초기화 단계)"이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(Runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서, 먼저 `소스코드의 평가(evaluation)` 과정을 거치면서 소스코드 실행을 위한 준비를 한다.
- 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
- 소스코드 평가 과정이 끝나면, 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- 즉, 엔진은 `변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 가장 먼저 실행` → **변수 선언이 어디에 위치하던 상관없이 어디서든 변수를 참조할 수 있다.** ( ReferenceError가 발생하지 않는 이유 )

```jsx
var person = "YOUNG MIN"; // 변수 선언과 값의 할당을 한 문장으로 표현 -> 내부적으로 실행시점은 각각 다름
```

- 변수 선언 : `런타임 이전에 먼저 실행`
- 값의 할당 : `런타임에 실행`

```jsx
// Example

console.log(score); // undefined

var score = 10; // 변수 선언 & 값의 할당

console.log(score); // YOUNG MIN
```

이처럼, **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 `변수 호이스팅` 이라고 한다.**

## 변수 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 재할당 이라고 한다.

(상수는 x) 

변수를 재할당할 때에는 이전 값이 저장되어 있던 메모리 공간을 지우고, `**다른 새로운 메모리 공간을 확보하고, 그 메모리 공간에 값을 저장한다.**` 

```jsx
var score; //undefined
score = 80; //새로운 메모리 공간을 확보하여 80 저장
score = 90; // 새로운 메모리 공간을 확보하여 90 저장
```

처음에  초기화 되었던 undefined와 80은 메모리에서 자동 해제되는데, 이러한 더이상 사용되지 않는 메모리를 해제하는 기능을 `**가비지 콜렉터**`라고 한다.

## 네이밍 규칙

**네이밍 컨벤션(Naming Convention)**

> 하나 이상의 영단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙
> 
- 주요 4가지 유형 네이밍 컨벤션

```
// 카멜 케이스(camelCase)
var fistMan;

// 스네이크 케이스(snake_case)
var first_man;

// 파스칼 케이스(PascalCase)
var FirstMan;

// 헝가리언 케이스(typeHungarianCase)
var strFirstMan;
var $elem = document.getElementById("myId");
var observable$ = fromEvent(document, "click");
```

- 자바스크립트에서는 일반적으로
    - `변수` 나 `함수` 이름에는 `카멜 케이스(camelCase)`
    - `생성자 함수`, `클래스 이름` 에는 `파스칼 케이스(PascalCase)`