
# 원시 값과 객체의 비교


## 원시 타입 vs 객체 타입
- 원시 타입의 값, 즉 `원시 값`은 **변경 불가능한 값(immutable value)** vs  `객체(참조) 타입의 값`, 즉 객체는 **변경 가능한 값(mutable value)**이다.
- `원시 값`을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장** vs `객체` 를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**
- `원시 값을 갖는 변수`를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**(**값에 의한 전달**)  vs  `객체를 가리키는 변수`를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**(**참조에 의한 전달**)

## 원시 값

**원시 값: 원시 타입의 값, 원시 값은 변경 불가능한 값**(`읽기 전용의 값(readonly)`)

**❗ 변수와 값은 엄연히 다른것!**
- `변수`는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**
- `값`은 변수에 저장된 **데이터 표현식이 평가되어 생성된 결과**
- 변경 불가능한 것은 **값에 대한 진술**, 변수는 재할당을 통해, 변수 값을 변경(교체) 가능

** 변수vs상수 **
+ 변수는 언제든지 `재할당`을 통해 변수 값을 변경(교체)할 수 있다. 그래서 "변수"다.
+ 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.
+ 하지만, 상수는 단 한 번만 할당이 허용하므로 변수 값을 변경할 수 없다. (이를 변경 불가능한 값으로 동일시하면 안됨 상수는 **재할당이 금지된 변수**)

###  불변성
변경 불가능한 값인 **원시 값**은 값을 변경하는 것이 아닌, 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 `불변성` 이라고 한다.  

**`불변성` 을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법**이 없다.

### 문자열과 불변성
자바스크립트는 개발자의 편의를 위해 문자열 타입을 원시 타입으로 제공한다.

문자열은 유사 배열객체이면서 이터러블이므로 **배열과 유사하게 각 문자에 접근**할 수 있다.

**유사 배열 객체란?**

- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체
- length 프로퍼티를 갖기 때문에 유사 배열 객체 이며, for 문으로 순회도 할 수 있다.
	```js
	var str = 'string';
	// 유사배열이므로, 배열과 유사하게 인덱스를 사용해 각 문자로 접근
	console.log(str[0]);
	// 원시 값인 문자열이 객체처럼 동작
	console.log(str.length); //6
	console.log(str.toUpperCase()); //STRING
	```
```js
var str = 'string'
// 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생 x
str[0] = 'S'
console.log(str)// string
```
이는 데이터의 신뢰성을 보장한다. 변수에 새로운 문자열을 재할당하는 것은 물론 가능

### 값에 의한 전달
```js
var score = 80;
var copy = score;

score = 100;

console.log(score); // 100 (원본 값)
console.log(copy); // 80  (복사한 값)
```
score는 변수 값 80으로 평가 되므로, copy 변수에도 80이 할당된다. 이때 새로운 숫자 값 80이 생성되어 copy변수에 할당된다

변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어 전달**된다. 
 이를,  `값에 의한 전달`이라고 한다.

copy와 score는 별개의 값으로써, 서로의 변수의 값에 어떠한 영향도 주지않음.

또한,
엄격하게 말하자면, 변수에는 값이 전달되는 것이 아니라, **메모리 주소가 전달되는 것이다.**
이는 변수와 같은 식별자는 값이 아니라 **메모리 주소를 기억**하기 때문이다.
> 이처럼 "값에 의한 전달"도 사실은 값을 전달하는 것이 아니라, 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

하지만 중요한 것은,

❗ **결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**