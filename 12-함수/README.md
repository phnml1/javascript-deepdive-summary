# 함수
## 함수를 사용하는 이유

- 코드의 재사용
	- 동일한 작업을 반복적으로 수행해야 한다면 정의된 함수를 재사용하는 것이 효율적 
- 유지보수 편의성& 코드의 신뢰성 높임
	- 코드의 중복을 억제하고 재사용성 높이면 유지보수의 편의성 및 코드의 신뢰성을 높인다.
- 코드의 가독성 향상

## 함수 리터럴
자바스크립트의 함수는 객체 타입의 값이다. 따라서 숫자나, 객체 처럼 **함수도 함수 리터럴로 생성이 가능하다.**  함수는 객체이고, 일반 객체 와는 다르게 **함수는 호출도 가능하다**

``` js
var f = function add(x,y) {

}
// 여기서 add는 함수 이름, 
// (x,y)는 매개변수 목록 
// {}는 함수 몸체
```

## 함수 정의

`함수 정의`란 함수를 호출하기 이전에 인수를 전달받을 **매개변수**와 **실행할 문들**, 그리고 **반환할 값**을 지정하는 것을 말한다.

함수를 정의하는 방법에는 4가지가 있다.

- 함수 선언문
	```js
	function add(x,y) {
		return x+y;
	}
	```
- 함수 표현식
	```js
	var add = function (x,y) {
		return x + y;
	}
	```
- Function 생성자 함수
	```js
	var add = new Function('x','y',' return x + y');
	```
-  화살표 함수(ES6)
	```js
	var add = (x,y) => x+y;
	```


## 함수 선언문 vs 함수 리터럴 표현식
함수 선언문은 표현식이 아닌 문이고, 함수 리터럴은 표현식이다. 다만, 함수 리터럴은 함수 이름을 생략할 수 있다.

둘의 형태가 동일하므로 자바스크립트 엔진은 코드의 문맥에 따라 둘을 구분한다.
예를 들어, **함수 리터럴을 함수 이름이 있게, 단독으로 사용한다면** `함수 선언문`으로 해석하고, **함수 리터럴이 값으로 평가되어야 하는 문맥, 변수에 할당하거나 피연산자로 사용하면** `함수 리터럴 표현식`으로 해석한다.
```js
function foo () {
	console.log("foo"); // foo
}
foo();

(function bar() { console.log('bar') });
bar(); // Refernce Error bar is defined
```
함수리터럴 foo는 단독으로 사용되었으므로, `함수 선언문`으로 해석되지만, 그룹 연산자()내에 있는 함수 리터럴(bar)는 `함수  리터럴 표현식`으로 해석된다.

**하지만, 함수 선언문 foo는 호출할 수 있지만, 함수 리터럴 표현식 bar는 호출할 수 없다.**

왜?

함수 이름은  **함수 몸체 내에서만 참조할 수 있는 식별자다.**

함수 몸체 외부에서는 함수 이름으로  함수를 참조할 수 없으므로, 함수를 호출할 수 없다. = 즉, 함수를 가리키는 **식별자가 없다** 


함수 리터럴 표현식으로 함수를 호출할 시, 메모리 구조는 다음과 같다.
![alt text](KakaoTalk_20240429_141013863.jpg)
하지만, 함수 선언문으로 함수를 호출할 시 메모리 구조는 다음과 같다.
![alt text](KakaoTalk_20240429_134057275_01.jpg)
여기서 foo는 자바스크립트 엔진이 **암묵적으로 생성한 식별자이다.**

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체로 생성한다. **생성된 함수를 호출하기 위해, 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.**

이를 의사코드로 표현하면, 
```js
// 여기서 var add의 add식별자로 함수가 호출되는 것!
var add = function add (x,y) {
	return x+y;
}
console.log(add(2,3)); 


// 함수 이름은 함수 몸체 내부에서만 유효함
// 함수 이름으로 호출한다면, Reference Error
console.log(foo(2,5)) //Reference Error: foo is defined
```
위의 의사코드는 사실, `함수 표현식`이라고 하고, `함수 선언문`는 "표현식이 아닌 문"이고,  `함수 표현식`은 "표현식인 문"이다.

## 함수 생성 시점과 함수 호이스팅

```js
// 함수 참조
console.dir(add) // f add(x,y)
console.dir(sub) // undefined

// 함수 호출
console.log(add(2,3)); // 7
console.log(sub(2,3)); // Type Error

// 함수 선언문
function add(x,y) {
	return x+y;
}

// 함수 표현식
var sub = function (x,y) {
	return x-y;
};
```
**함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성시점은 다르다.**

- 함수 선언문에서는 런타임 이전에 **이미 함수 객체를 생성하고 식별자에 할당한다.**

- 함수 선언문이 코드의 선두로 끌어올려진 것 처럼 동작하는 것을 `함수 호이스팅`이라고 한다.
- `함수 호이스팅`과 다르게 `변수 호이스팅`은 `undefined`로 초기화되고, `함수 호이스팅`의 식별자는 `함수 객체`로 초기화 된다.
-  함수 표현식은 **변수에 할당되는 값이 함수인 것**이므로, `변수 호이스팅`이 발생한다.

